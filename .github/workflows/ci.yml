
name: ci
on:
  pull_request:

env:
  FSTAR_VERSION: v2025.08.07
  FIRST_PARTY_ONLY: 1

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: '1.86.0'
          override: true
      - uses: Swatinem/rust-cache@v2
      - name: node binary build (cli features)
        run: cargo build --bin node --features cli
      - id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            monitoring:
              - 'monitoring/**'
              - 'node/src/telemetry.rs'
        - name: install monitoring deps
          run: npm ci --prefix monitoring
        - name: monitor smoke
          run: |
            set -e
            make monitor --native-monitor &
            pid=$!
            sleep 5
            kill $pid
            wait $pid || true
      - name: lint grafana dashboard
        if: steps.changes.outputs.monitoring == 'true'
        run: |
          set -o pipefail
          make -C monitoring lint 2>&1 | tee monitoring/lint.log
      - name: verify dashboard up-to-date
        if: steps.changes.outputs.monitoring == 'true'
        run: git diff --exit-code monitoring/metrics.json monitoring/grafana/dashboard.json
      - name: upload grafana lint log
        if: always() && steps.changes.outputs.monitoring == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-lint
          path: monitoring/lint.log
      - name: install fstar
        run: scripts/install_fstar.sh
      - name: fstar installer failure check
        run: scripts/test_install_fstar.sh
      - name: install python runtime
        run: |
          sudo apt-get update
          sudo apt-get install -y patchelf software-properties-common
          sudo add-apt-repository -y ppa:deadsnakes/ppa
          sudo apt-get update
          sudo apt-get install -y python3.12 python3.12-dev
      - name: install just and demo venv
        run: |
          cargo install just --locked
          python3.12 -m venv .venv
      - name: demo smoke test
        run: just demo
      - name: discover libpython
        run: |
          echo "LIBPYTHON_PATH=$(python3-config --ldflags | sed -n 's/.*-L\([^ ]*\).*/\1/p')" >> $GITHUB_ENV
      - name: install cargo-nextest
        run: cargo install cargo-nextest --locked
      - name: verify cargo-nextest
        run: cargo nextest --version
      - name: cargo nextest
        run: |
          cargo nextest run --profile quic --features telemetry 2>&1 | tee quic-nextest.log
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: auto profile
        run: cargo run -p auto-profile --release
      - name: upload quic nextest log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quic-nextest
          path: quic-nextest.log
      - name: gossip test
        run: cargo nextest run --profile quic gossip_converges_to_longest_chain --retries 2
        env:
          RUST_TEST_THREADS: 1
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: compute-market nextest
        run: cargo nextest run --features telemetry compute_market::courier_retry_updates_metrics price_board
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: range boost telemetry tests
        run: just test-range-boost
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: governance failover smoke
        run: cargo test -p governance executor_failover_preserves_nonce_watermark
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: metrics naming check
        run: cargo test -p metrics-aggregator --test naming
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: monitoring crate tests
        run: cargo test --manifest-path monitoring/Cargo.toml
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: bridge alert validator
        run: cargo run --manifest-path monitoring/Cargo.toml --bin bridge-alert-validator
      - name: doc ci
        run: make doc-ci
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: validate treasury disbursement schema
        run: cargo run -p contract-cli --features telemetry -- gov disburse preview --json examples/governance/disbursement_example.json --check
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
      - name: install windows cross-target
        run: rustup target add x86_64-pc-windows-gnu
      - name: windows target check (sys/runtime)
        run: |
          cargo check --target x86_64-pc-windows-gnu -p sys
          cargo check --target x86_64-pc-windows-gnu -p runtime
      - name: cargo audit
        run: |
          cargo install cargo-audit --locked
          cargo audit --deny warnings
      - name: generate sbom
        run: |
          cargo install cargo-cyclonedx --locked
          cargo cyclonedx --all --format xml --output sbom.xml
      - name: dependency policy check
        id: dependency_audit
        continue-on-error: true
        run: |
          set -o pipefail
          mkdir -p target/dependency-registry
          cargo run -p dependency_registry -- --check --out-dir target/dependency-registry config/dependency_policies.toml
      - name: upload dependency registry
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-registry
          path: |
            target/dependency-registry/dependency-registry.json
            target/dependency-registry/dependency-violations.json
          if-no-files-found: warn
      - name: dependency policy summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { summary, setFailed } = require('@actions/core');

            const registryPath = 'target/dependency-registry/dependency-registry.json';
            const violationsPath = 'target/dependency-registry/dependency-violations.json';
            const outcome = '${{ steps.dependency_audit.outcome }}';

            let registry = null;
            let violations = { entries: [] };

            const readJson = (p) => JSON.parse(fs.readFileSync(p, 'utf8'));

            summary.addHeading('Dependency policy check');

            if (fs.existsSync(registryPath)) {
              try {
                registry = readJson(registryPath);
              } catch (error) {
                summary.addRaw(`Failed to parse \`${registryPath}\`: ${error.message}`, true);
              }
            } else {
              summary.addRaw(`Registry output not found at \`${registryPath}\`.`, true);
            }

            if (fs.existsSync(violationsPath)) {
              try {
                violations = readJson(violationsPath);
              } catch (error) {
                summary.addRaw(`Failed to parse \`${violationsPath}\`: ${error.message}`, true);
              }
            } else {
              summary.addRaw(`Violation report not found at \`${violationsPath}\`.`, true);
            }

            if (registry && Array.isArray(registry.entries)) {
              summary.addRaw(`Policy depth limit: ${registry.policy?.max_depth ?? 'n/a'}`, true);
            }

            if (registry && Array.isArray(violations.entries) && violations.entries.length > 0) {
              const lookup = new Map();
              for (const entry of registry.entries) {
                lookup.set(`${entry.name}@${entry.version}`, entry);
              }

              const rows = [[
                { data: 'Crate', header: true },
                { data: 'Version', header: true },
                { data: 'Policy tier', header: true },
                { data: 'Reason', header: true },
              ]];

              for (const violation of violations.entries) {
                const key = `${violation.name}@${violation.version}`;
                const entry = lookup.get(key);
                rows.push([
                  `\`${violation.name}\``,
                  violation.version,
                  entry?.tier ?? '—',
                  violation.detail,
                ]);
              }

              summary.addRaw(`Violations detected: ${violations.entries.length}`, true);
              summary.addTable(rows);
            } else if (registry && Array.isArray(violations.entries)) {
              summary.addRaw('No dependency policy violations detected. ✅', true);
            }

            await summary.write();

            if (outcome === 'failure' || (Array.isArray(violations.entries) && violations.entries.length > 0)) {
              setFailed('Dependency policy check reported violations.');
            }
      - name: tokio usage audit
        run: cargo run --manifest-path tools/xtask/Cargo.toml --bin refcheck
      - name: sign image
        run: scripts/sign-image.sh theblock/node:latest
      - name: verify container image
        run: scripts/verify_image.sh theblock/node:latest
      - name: snapshot restore
        run: scripts/snapshot_ci.sh
        env:
          LD_LIBRARY_PATH: ${{ env.LIBPYTHON_PATH }}
  fuzz-net:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: '1.86.0'
          override: true
      - name: install honggfuzz
        run: cargo install honggfuzz --locked
      - name: run network fuzz
        run: |
          cargo hfuzz run network --iterations 10 || true
  arm-tests:
    runs-on: [self-hosted, arm]
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: '1.86.0'
          override: true
      - name: run tests on arm
        run: cargo test --all --release || true
  wal-fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          profile: minimal
          override: true
      - uses: actions/cache@v3
        with:
          path: |
            ~/.cargo
            target
            fuzz/artifacts
            net/fuzz/artifacts
            gateway/fuzz/artifacts
          key: ${{ runner.os }}-wal-fuzz-${{ hashFiles('Cargo.lock') }}
      - name: install cargo-fuzz
        run: cargo install cargo-fuzz --locked
      - name: run wal fuzz
        run: cargo +nightly fuzz run wal_fuzz -- -max_total_time=120 -artifact_prefix=fuzz/wal/ -runs=0 || true
      - name: upload wal artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: wal-fuzz
          path: fuzz/wal/
      - name: verify no artifacts
        run: |
          if ls fuzz/wal/* 1> /dev/null 2>&1; then
            echo "Artifacts found";
            exit 1;
          fi
  compute-market-fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          profile: minimal
          override: true
      - uses: actions/cache@v3
        with:
          path: |
            ~/.cargo
            target
            fuzz/artifacts
          key: ${{ runner.os }}-compute-market-fuzz-${{ hashFiles('Cargo.lock') }}
      - name: install cargo-fuzz
        run: cargo install cargo-fuzz --locked
      - name: run compute_market fuzz
        run: cargo +nightly fuzz run compute_market -- -max_total_time=120 -artifact_prefix=fuzz/compute_market/ -runs=0 || true
      - name: run network fuzz
        run: cargo +nightly fuzz run network -- -max_total_time=120 -artifact_prefix=fuzz/network/artifacts/ -runs=0 || true
      - name: run localnet proximity fuzz
        run: cargo +nightly fuzz run localnet_proximity -- -max_total_time=120 -artifact_prefix=fuzz/localnet_proximity/ -runs=0 || true
      - name: run quic frame fuzz
        run: cargo +nightly fuzz run quic_frame -- -max_total_time=120 -artifact_prefix=fuzz/quic/ -runs=0 || true
      - name: run peer id fuzz
        working-directory: net/fuzz
        run: cargo +nightly fuzz run peer_id -- -max_total_time=120 -artifact_prefix=artifacts/ -runs=0 || true
      - name: run gateway http fuzz
        working-directory: gateway/fuzz
        run: cargo +nightly fuzz run http_request -- -max_total_time=120 -artifact_prefix=artifacts/ -runs=0 || true
      - name: fuzz coverage report
        run: scripts/fuzz_coverage.sh
      - name: upload compute-market artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compute-market-fuzz
          path: fuzz/compute_market/
      - name: upload network artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: network-fuzz
          path: fuzz/network/artifacts/
      - name: upload quic frame artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quic-frame-fuzz
          path: fuzz/quic/
      - name: upload peer-id artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: peer-id-fuzz
          path: net/fuzz/artifacts/
      - name: upload gateway artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gateway-fuzz
          path: gateway/fuzz/artifacts/
      - name: upload fuzz coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fuzz-coverage
          path: fuzz/coverage
      - name: verify no compute-market artifacts
        run: |
          if ls fuzz/compute_market/* 1> /dev/null 2>&1; then
            echo "Artifacts found";
            exit 1;
          fi
      - name: verify no network artifacts
        run: |
          if ls fuzz/network/artifacts/* 1> /dev/null 2>&1; then
            echo "Artifacts found";
            exit 1;
          fi
      - name: verify no peer-id artifacts
        run: |
          if ls net/fuzz/artifacts/* 1> /dev/null 2>&1; then
            echo "Artifacts found";
            exit 1;
          fi
      - name: verify no gateway artifacts
        run: |
          if ls gateway/fuzz/artifacts/* 1> /dev/null 2>&1; then
            echo "Artifacts found";
            exit 1;
          fi
      - name: verify no quic fuzz artifacts
        run: |
          if ls fuzz/quic/* 1> /dev/null 2>&1; then
            echo "Artifacts found";
            exit 1;
          fi
  settlement-audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: '1.86.0'
          override: true
      - uses: Swatinem/rust-cache@v2
      - name: settlement audit
        run: cargo test -p the_block --test settlement_audit --release

  quantum:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: [x86_64-unknown-linux-gnu, aarch64-unknown-linux-gnu]
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: "1.86.0"
          override: true
          target: ${{ matrix.target }}
      - uses: Swatinem/rust-cache@v2
      - name: test quantum
        run: cargo test --all --features "quantum test-telemetry" --release
