# Protocol Placeholder Burn-Down List

Per the “spec-first” contract we keep *docs describing reality*. This tracker captures the remaining protocol-critical placeholders (consensus, blob anchoring, wallet UX) so each gets:

1. **Spec reference** – points to the canonical doc that expects the feature to be production-grade.
2. **Implementation plan** – concrete steps to remove the placeholder or explicitly gate it.
3. **Determinism test** – the regression guard (usually `cargo test -p the_block --test replay` or a wallet-specific vector) that must pass once the work lands.

| Placeholder | Spec reference | Implementation plan | Determinism test |
|-------------|----------------|---------------------|------------------|
| **Blob chain root scheduler in `node/src/blob_chain.rs`** | [`docs/architecture.md#ledger-and-consensus`](docs/architecture.md#ledger-and-consensus) + [`docs/block_os-spec/01-core-l1.md#blob-root-scheduler`](docs/block_os-spec/01-core-l1.md#blob-root-scheduler) describe deterministic blob roots being captured per tick, anchored in storage manifests, and exposed via the header hash layout. | 1. Build the `RootAssembler` so new blob roots are derived from the manifest (shard, receipt hash, byte counts) and persisted alongside `hashlayout` data.<br>2. Wire the new root fields through `node/src/hashlayout.rs` and the block header serialization so macro validators can anchor them in `node/src/block_binary.rs`/`blob_chain` storage.<br>3. Add receipts/CLI telemetry that proves the root ordering and manifest entries match the scheduler before light clients consume them. | `cargo test -p the_block --test replay` (blaze `sim/` replay once `blob_chain` reflections exist) plus a replay vector that asserts the recorded roots match the manifest when driven from the same seed. |
| **Pietrzak modulus placeholder in `node/src/consensus/vdf.rs`** | [`docs/system_reference.md#12-poh-and-vdf-parameters`](docs/system_reference.md#12-poh-and-vdf-parameters) and [`docs/architecture.md#difficulty-and-proof-of-history`](docs/architecture.md#difficulty-and-proof-of-history) require real VDF randomness with configurable modulus parameters instead of fixed 512-bit stubs. | 1. Replace the `MODULUS_BITS` placeholder with a governance-backed parameter (mirror `node/src/config.rs::InflationConfig`’s VDF section).<br>2. Carry the Pietrzak modulus into the VDF proof generator/ verifier (e.g., via a pre-computed prime bundler) and document expected proof lengths.<br>3. Supply deterministic test vectors (seed → output/proof) so future changes flag regressions. | `cargo test -p the_block --test replay` (ensures every replay re-computes the VDF chain with the chosen modulus) plus a new `node/tests/vdf.rs` vector using the published modulus/proof pair. |
| **HD derivation stub in `crates/wallet/src/hd.rs`** | [`docs/security_and_privacy.md#remote-signers-and-key-management`](docs/security_and_privacy.md#remote-signers-and-key-management) names the wallet and remote signer stack as the canonical key-management surface; BIP32 compliance is implied for operator tooling and UX parity. | Either deliver a full BIP32 implementation (covering path parsing, hardened vs soft children, and checksum validation) or gate the existing stub behind a feature flag (`TB_WALLET_HD_STUB`). | `cargo test -p wallet --test hd` (new test vectors from BIP32 test cases) plus `cargo test -p the_block --test replay` to ensure key derivations remain deterministic even when remote signer rotations or feature flags toggle. |

## Next steps

- Track each item in its subsystem backlog (blob & storage, consensus, wallet) and tag the owner listed in [`docs/overview.md#document-map`](docs/overview.md#document-map) before coding.<br>
- Once the implementation plan is underway, update this doc with progress notes and the PR links so reviewers can verify the placeholder is really gone.<br>
- Add the determinism test command to the subsystem checklist so it is rerun whenever these critical paths change.
