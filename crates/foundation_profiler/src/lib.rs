#![forbid(unsafe_code)]

use std::backtrace::Backtrace;
use std::collections::hash_map::DefaultHasher;
use std::collections::BTreeMap;
use std::fmt;
use std::hash::{Hash, Hasher};
use std::io::{self, Write};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant};

/// Result alias used throughout the profiler facade.
pub type Result<T> = std::result::Result<T, Error>;

/// Error emitted by the profiler facade.
#[derive(Debug, Clone)]
pub struct Error {
    message: String,
}

impl Error {
    fn new(message: impl Into<String>) -> Self {
        Self {
            message: message.into(),
        }
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for Error {}

struct Inner {
    samples: Mutex<Vec<Vec<String>>>,
    running: AtomicBool,
    handle: Mutex<Option<thread::JoinHandle<()>>>,
}

impl Inner {
    fn new() -> Self {
        Self {
            samples: Mutex::new(Vec::new()),
            running: AtomicBool::new(false),
            handle: Mutex::new(None),
        }
    }
}

/// Active profiler guard returned by [`ProfilerGuard::new`].
pub struct ProfilerGuard {
    inner: Arc<Inner>,
    frequency: u32,
    start: Instant,
}

impl ProfilerGuard {
    /// Start a new sampling profiler running at `frequency` Hertz.
    pub fn new(frequency: i32) -> Option<Self> {
        if frequency <= 0 {
            return None;
        }
        let frequency = frequency as u32;
        let inner = Arc::new(Inner::new());
        inner.running.store(true, Ordering::SeqCst);
        let thread_inner = Arc::clone(&inner);
        let sleep = Duration::from_secs_f64(1.0 / frequency.max(1) as f64);
        let handle = thread::Builder::new()
            .name("foundation-profiler".into())
            .spawn(move || sample_loop(thread_inner, sleep))
            .ok()?;
        *inner.handle.lock().expect("handle mutex poisoned") = Some(handle);
        Some(Self {
            inner,
            frequency,
            start: Instant::now(),
        })
    }

    /// Produce a report builder tied to this guard.
    pub fn report(&self) -> ReportBuilder {
        ReportBuilder {
            inner: Arc::clone(&self.inner),
            started: self.start,
            frequency: self.frequency,
        }
    }
}

impl Drop for ProfilerGuard {
    fn drop(&mut self) {
        stop_sampling(&self.inner);
    }
}

fn sample_loop(inner: Arc<Inner>, sleep: Duration) {
    while inner.running.load(Ordering::Relaxed) {
        let backtrace = Backtrace::force_capture();
        let mut frames = Vec::new();
        for line in format!("{backtrace}").lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() || trimmed.eq_ignore_ascii_case("stack backtrace:") {
                continue;
            }
            // Lines typically start with an index like "0:"; strip it for readability.
            let without_index = trimmed
                .split_once(':')
                .map(|(_, rest)| rest.trim_start())
                .unwrap_or(trimmed);
            frames.push(without_index.to_string());
        }
        if let Some(stack) = normalise_stack(&frames) {
            if let Ok(mut guard) = inner.samples.lock() {
                guard.push(stack);
            }
        }
        thread::sleep(sleep);
    }
}

fn normalise_stack(frames: &[String]) -> Option<Vec<String>> {
    if frames.is_empty() {
        return None;
    }
    // Skip frames generated by the profiler itself.
    let mut trimmed = Vec::with_capacity(frames.len());
    let mut skip_prefix = true;
    for name in frames.iter().rev() {
        if skip_prefix {
            if name.contains("foundation_profiler") {
                continue;
            }
            skip_prefix = false;
        }
        if trimmed.last().map_or(false, |prev: &String| prev == name) {
            continue;
        }
        trimmed.push(name.clone());
        if trimmed.len() >= 128 {
            break;
        }
    }
    if trimmed.is_empty() {
        None
    } else {
        Some(trimmed)
    }
}

fn stop_sampling(inner: &Arc<Inner>) {
    inner.running.store(false, Ordering::SeqCst);
    if let Ok(mut guard) = inner.handle.lock() {
        if let Some(handle) = guard.take() {
            let _ = handle.join();
        }
    }
}

/// Builder returned by [`ProfilerGuard::report`].
pub struct ReportBuilder {
    inner: Arc<Inner>,
    started: Instant,
    frequency: u32,
}

impl ReportBuilder {
    /// Finalise the profiler and generate a report summarising all captured samples.
    pub fn build(self) -> Result<Report> {
        stop_sampling(&self.inner);
        let samples = self
            .inner
            .samples
            .lock()
            .map_err(|_| Error::new("profiler samples poisoned"))?
            .clone();
        Ok(Report::from_samples(samples, self.started, self.frequency))
    }
}

/// Aggregated profiler report.
pub struct Report {
    root: FlameNode,
    total_samples: u64,
    duration: Duration,
    frequency: u32,
}

impl Report {
    fn from_samples(samples: Vec<Vec<String>>, started: Instant, frequency: u32) -> Self {
        let mut root = FlameNode::root();
        let mut total_samples = 0u64;
        for stack in samples {
            if stack.is_empty() {
                continue;
            }
            root.insert(&stack);
            total_samples += 1;
        }
        Self {
            root,
            total_samples,
            duration: started.elapsed(),
            frequency,
        }
    }

    /// Number of samples captured.
    pub fn samples(&self) -> u64 {
        self.total_samples
    }

    /// Duration the profiler was active for.
    pub fn duration(&self) -> Duration {
        self.duration
    }

    /// Sampling frequency in Hertz requested when constructing the guard.
    pub fn frequency(&self) -> u32 {
        self.frequency
    }

    /// Render a flamegraph SVG to the provided writer.
    pub fn flamegraph<W: Write>(&self, mut writer: W) -> io::Result<()> {
        const WIDTH: f64 = 1200.0;
        const FRAME_HEIGHT: f64 = 18.0;
        const GAP: f64 = 4.0;
        let depth = self.root.max_depth();
        let height = (depth as f64 + 1.0) * (FRAME_HEIGHT + GAP) + 40.0;
        writeln!(writer, "<?xml version=\"1.0\" standalone=\"no\"?>")?;
        writeln!(
            writer,
            "<svg version=\"1.1\" width=\"{WIDTH}\" height=\"{height}\" \\"
        )?;
        writeln!(
            writer,
            "     xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">"
        )?;
        writeln!(writer, "<style>text {{ font-family: sans-serif; }}</style>")?;
        writeln!(
            writer,
            "<rect x=\"0\" y=\"0\" width=\"{WIDTH}\" height=\"{height}\" fill=\"#ffffff\"/>"
        )?;
        if self.total_samples == 0 {
            writeln!(
                writer,
                "<text x=\"20\" y=\"40\" font-size=\"24\" fill=\"#333\">No samples captured</text>"
            )?;
            writeln!(writer, "</svg>")?;
            return Ok(());
        }
        let scale = WIDTH / self.total_samples as f64;
        render_children(
            &mut writer,
            &self.root,
            0,
            0.0,
            scale,
            FRAME_HEIGHT,
            GAP,
            self.total_samples,
        )?;
        writeln!(writer, "</svg>")
    }
}

fn render_children<W: Write>(
    writer: &mut W,
    node: &FlameNode,
    depth: usize,
    mut offset: f64,
    scale: f64,
    frame_height: f64,
    gap: f64,
    total_samples: u64,
) -> io::Result<()> {
    for child in node.children.values() {
        let width = child.count as f64 * scale;
        let x = offset;
        let y = depth as f64 * (frame_height + gap) + 20.0;
        let (r, g, b) = colour_for(&child.name);
        let percent = if total_samples == 0 {
            0.0
        } else {
            child.count as f64 * 100.0 / total_samples as f64
        };
        writeln!(
            writer,
            "<g><title>{} — {} samples ({percent:.2}%)</title>",
            escape_xml(&child.name),
            child.count
        )?;
        writeln!(
            writer,
            "<rect x=\"{x:.2}\" y=\"{y:.2}\" width=\"{width:.2}\" height=\"{frame_height:.2}\" fill=\"rgb({r},{g},{b})\" stroke=\"#333\" stroke-width=\"0.5\"/>"
        )?;
        if width > 32.0 {
            let label = shorten_label(&child.name, width / 9.0);
            writeln!(
                writer,
                "<text x=\"{:.2}\" y=\"{:.2}\" font-size=\"10\" fill=\"#000\">{}</text>",
                x + 3.0,
                y + frame_height - 4.0,
                escape_xml(&label)
            )?;
        }
        writeln!(writer, "</g>")?;
        render_children(
            writer,
            child,
            depth + 1,
            offset,
            scale,
            frame_height,
            gap,
            total_samples,
        )?;
        offset += width;
    }
    Ok(())
}

fn colour_for(name: &str) -> (u8, u8, u8) {
    let mut hasher = DefaultHasher::new();
    name.hash(&mut hasher);
    let hash = hasher.finish();
    let r = ((hash & 0xff) as u8).saturating_add(64);
    let g = (((hash >> 8) & 0xff) as u8).saturating_add(48);
    let b = (((hash >> 16) & 0xff) as u8).saturating_add(32);
    (r.min(255), g.min(255), b.min(255))
}

fn shorten_label(name: &str, max_chars: f64) -> String {
    let max_chars = max_chars.floor() as usize;
    if max_chars == 0 || name.len() <= max_chars {
        return name.to_string();
    }
    if max_chars <= 1 {
        return String::new();
    }
    let mut truncated = name.chars().take(max_chars - 1).collect::<String>();
    truncated.push('…');
    truncated
}

fn escape_xml(input: &str) -> String {
    input
        .chars()
        .flat_map(|c| match c {
            '&' => "&amp;".chars().collect::<Vec<char>>(),
            '<' => "&lt;".chars().collect(),
            '>' => "&gt;".chars().collect(),
            '"' => "&quot;".chars().collect(),
            '\'' => "&apos;".chars().collect(),
            _ => vec![c],
        })
        .collect()
}

#[derive(Default)]
struct FlameNode {
    name: String,
    count: u64,
    children: BTreeMap<String, FlameNode>,
}

impl FlameNode {
    fn root() -> Self {
        Self::default()
    }

    fn insert(&mut self, stack: &[String]) {
        self.count += 1;
        if let Some((head, tail)) = stack.split_first() {
            let child = self
                .children
                .entry(head.clone())
                .or_insert_with(|| FlameNode {
                    name: head.clone(),
                    ..FlameNode::default()
                });
            child.insert(tail);
        }
    }

    fn max_depth(&self) -> usize {
        let mut max = 0;
        for child in self.children.values() {
            max = max.max(1 + child.max_depth());
        }
        max
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn builds_tree() {
        let mut root = FlameNode::root();
        root.insert(&vec!["main".into(), "worker".into(), "task".into()]);
        root.insert(&vec!["main".into(), "worker".into(), "task".into()]);
        root.insert(&vec!["main".into(), "scheduler".into()]);
        assert_eq!(root.count, 3);
        assert_eq!(root.children.len(), 1);
        let main = root.children.get("main").unwrap();
        assert_eq!(main.count, 3);
        assert_eq!(main.children.len(), 2);
        assert!(main.children.contains_key("worker"));
        assert!(main.children.contains_key("scheduler"));
    }

    #[test]
    fn renders_svg_even_without_samples() {
        let report = Report::from_samples(Vec::new(), Instant::now(), 100);
        let mut buf = Vec::new();
        report.flamegraph(&mut buf).unwrap();
        let svg = String::from_utf8(buf).unwrap();
        assert!(svg.contains("No samples captured"));
    }
}
